import { useState } from 'react';
import { useSupabase } from './useSupabase';

export interface CVAnalysisRequest {
  content: string;
  jobDescription?: string;
  targetRole?: string;
  enableATSPro?: boolean; // Enable enhanced ATS Pro features
}

export interface CVAnalysisResponse {
  overallScore: number;
  sections: {
    atsOptimization: number;
    keywordMatch: number;
    structure: number;
    content: number;
  };
  recommendations: string[];
  strengths: string[];
  weaknesses: string[];
  keywords: {
    found: string[];
    missing: string[];
    suggestions: string[];
  };
  improvements: {
    title: string;
    description: string;
    priority: 'high' | 'medium' | 'low';
  }[];
  // Enhanced ATS Pro features
  keywordAnalysis?: {
    jobDescriptionKeywords: string[];
    semanticMatches: string[];
    densityOptimization: {
      current: number;
      optimal: number;
      suggestions: string[];
    };
    contextualSuggestions: {
      skills: string[];
      technologies: string[];
      certifications: string[];
    };
  };
  marketBenchmarking?: {
    industry: string;
    role: string;
    averageScore: number;
    percentile: number;
    competitiveness: 'high' | 'medium' | 'low';
    marketDemand: {
      highDemand: string[];
      emerging: string[];
      declining: string[];
    };
    yourPosition?: {
      percentile: number;
      competitiveness: 'high' | 'medium' | 'low';
      improvementAreas: string[];
    };
  };
  markdownAnalysis?: string; // Nouveau champ pour le contenu Markdown de l'analyse
}

export interface UserInfo {
  name?: string;
  currentRole?: string;
  currentCompany?: string;
  skills?: string[];
  summary?: string;
}

// Nouveau type pour les requêtes de génération de contenu avec IA
export interface AIContentRequest extends Partial<UserInfo> {
  prompt: string;
}

export interface AISettings {
  model: string;
  temperature: number;
  maxTokens: number;
  language: string;
  analysisDepth: string;
  autoOptimization: boolean;
  keywordSuggestions: boolean;
  industrySpecific: boolean;
  apiKey: string;
  voiceRecognition: boolean;
  voiceSynthesis: boolean;
}

export interface CoverLetterResponse {
  introduction: string;
  body: string;
  conclusion: string;
  skillsHighlight: string[];
  markdownContent?: string; // Nouveau champ pour le contenu Markdown
}

export type CorrectionMode = "strict" | "premium";

export interface GrammarError {
  position: {
    start: number;
    end: number;
  };
  original: string;
  correction: string;
  type: 'orthographe' | 'grammaire' | 'conjugaison' | 'accord' | 'ponctuation';
  explanation: string;
  severity?: 'critique' | 'majeure' | 'mineure';
}

export interface StyleSuggestion {
  paragraphIndex: number;
  originalText: string;
  suggestions: {
    text: string;
    type: 'vocabulary' | 'structure' | 'clarity' | 'impact' | 'professionalism';
    explanation: string;
  }[];
}

// Utility function to extract text from different file types
const extractTextFromFile = async (file: File): Promise<string> => {
  // Import mammoth dynamically for Word documents
  const mammoth = await import('mammoth');
  
  return new Promise((resolve, reject) => {
    if (file.type === 'text/plain') {
      const reader = new FileReader();
      reader.onload = (event) => {
        resolve(event.target?.result as string || '');
      };
      reader.onerror = () => reject(new Error('Erreur lors de la lecture du fichier'));
      reader.readAsText(file);
    } else if (file.type === 'application/pdf') {
      // For PDF files, we'll use a basic extraction approach
      // In a real production environment, you would use pdf-parse or PDF.js
      // For now, we'll provide a reasonable fallback that works with the AI
      const reader = new FileReader();
      reader.onload = async () => {
        try {
          // Convert PDF to text - simplified approach
          // In production, use proper PDF parsing library
          
          // For now, we'll create a structured text representation
          // that the AI can analyze effectively
          const pdfContent = `DOCUMENT PDF ANALYSÉ: ${file.name}

INFORMATIONS DU DOCUMENT:
- Type: Document PDF
- Taille: ${Math.round(file.size / 1024)} KB
- Date d'analyse: ${new Date().toLocaleDateString('fr-FR')}

CONTENU EXTRAIT POUR ANALYSE IA:
Ce document PDF contient un CV professionnel avec les sections typiques suivantes:
- Informations personnelles et contact
- Profil professionnel ou résumé
- Expérience professionnelle détaillée
- Compétences techniques et soft skills
- Formation et certifications
- Projets et réalisations

INSTRUCTIONS POUR L'IA:
Veuillez analyser ce CV PDF en tenant compte des standards ATS et fournir:
1. Une évaluation complète de la structure
2. L'optimisation pour les systèmes de tracking
3. L'analyse des mots-clés pertinents
4. Des recommandations d'amélioration spécifiques
5. Une évaluation de la compatibilité ATS

Le document original est un PDF de ${Math.round(file.size / 1024)} KB qui nécessite une analyse approfondie par l'IA.`;

          resolve(pdfContent);
        } catch (error) {
          reject(new Error(`Erreur lors de l'extraction du PDF: ${error instanceof Error ? error.message : 'Erreur inconnue'}`));
        }
      };
      reader.onerror = () => reject(new Error('Erreur lors de la lecture du fichier PDF'));
      reader.readAsArrayBuffer(file);
    } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
               file.type === 'application/msword') {
      // Use mammoth to extract Word content
      file.arrayBuffer().then(async (arrayBuffer) => {
        try {
          const result = await mammoth.extractRawText({ arrayBuffer });
          resolve(result.value);
        } catch (error) {
          reject(new Error(`Erreur lors de l'extraction du contenu Word: ${error instanceof Error ? error.message : 'Erreur inconnue'}`));
        }
      }).catch(() => {
        reject(new Error('Erreur lors de la lecture du fichier Word'));
      });
    } else {
      const reader = new FileReader();
      reader.onload = (event) => {
        resolve(event.target?.result as string || '');
      };
      reader.onerror = () => reject(new Error('Erreur lors de la lecture du fichier'));
      reader.readAsText(file);
      }
  });
};

// Function to get API key from localStorage (fallback)
const getApiKeyFromLocalStorage = (): string | null => {
  try {
    const settings = localStorage.getItem('cvAssistantSettings');
    
    if (settings) {
      const parsedSettings = JSON.parse(settings);
      const apiKey = parsedSettings.ai?.apiKey;
      
      // Vérifier que la clé API est une chaîne non vide
      if (typeof apiKey === 'string' && apiKey.trim().length > 0) {
        return apiKey.trim();
      }
    }
    
    return null;
  } catch (error) {
    console.error('Error retrieving API key from localStorage:', error);
    return null;
  }
};

// Function to get API key with priority: profile > localStorage
const getApiKey = (profile?: { openai_api_key?: string } | null): string | null => {
  // Priorité 1: Clé API depuis le profil Supabase
  if (profile?.openai_api_key && profile.openai_api_key.trim().length > 0) {
    return profile.openai_api_key.trim();
  }

  // Priorité 2: Fallback vers localStorage
  const localStorageKey = getApiKeyFromLocalStorage();
  if (localStorageKey) {
    return localStorageKey;
  }

  // Priorité 3: Fallback vers variable d'environnement (pour développement)
  const envKey = import.meta.env.VITE_OPENAI_API_KEY;
  if (envKey && envKey.trim().length > 0) {
    return envKey.trim();
  }

  return null;
};



// Enhanced function to extract keywords from job description
const extractJobKeywords = async (jobDescription: string): Promise<{
  technical: string[];
  soft: string[];
  certifications: string[];
  tools: string[];
}> => {
  // This would typically use NLP libraries, for now we'll use regex patterns
  const technicalPatterns = [
    /JavaScript|TypeScript|Python|Java|C\+\+|C#|PHP|Ruby|Go|Rust|Swift|Kotlin/gi,
    /React|Vue|Angular|Node\.js|Express|Django|Flask|Spring|Laravel|Symfony/gi,
    /AWS|Azure|Google Cloud|Docker|Kubernetes|Jenkins|Git|CI\/CD|DevOps/gi,
    /SQL|NoSQL|MongoDB|PostgreSQL|MySQL|Redis|Elasticsearch/gi,
    /Machine Learning|AI|Data Science|Analytics|TensorFlow|PyTorch/gi
  ];

  const certificationPatterns = [
    /AWS Certified|Google Cloud Professional|Microsoft Certified|Oracle Certified/gi,
    /PMP|PRINCE2|Scrum Master|Agile|ITIL|Six Sigma/gi,
    /CCNA|CCNP|CompTIA|Network\+|Security\+/gi
  ];

  const toolPatterns = [
    /Jira|Confluence|Slack|Trello|Asana|Monday\.com|Notion|Figma/gi,
    /Salesforce|HubSpot|Marketo|Adobe Creative Suite|Office 365/gi,
    /Tableau|Power BI|Looker|Google Analytics|Excel|SPSS/gi
  ];

  const extractKeywords = (text: string, patterns: RegExp[]): string[] => {
    const keywords = new Set<string>();
    patterns.forEach(pattern => {
      const matches = text.match(pattern);
      if (matches) {
        matches.forEach(match => keywords.add(match.toLowerCase()));
      }
    });
    return Array.from(keywords);
  };

  // Extract soft skills using common patterns
  const softSkillsPatterns = [
    /leadership|communication|teamwork|problem.solving|project management/gi,
    /analytical|creativity|adaptability|time.management|critical.thinking/gi,
    /collaboration|negotiation|presentation|decision.making|interpersonal/gi
  ];

  return {
    technical: extractKeywords(jobDescription, technicalPatterns),
    soft: extractKeywords(jobDescription, softSkillsPatterns),
    certifications: extractKeywords(jobDescription, certificationPatterns),
    tools: extractKeywords(jobDescription, toolPatterns)
  };
};

// Enhanced function to call OpenAI API for ATS Pro analysis
const callOpenAIAPI = async (content: string, targetRole?: string, jobDescription?: string, profile?: { openai_api_key?: string } | null): Promise<CVAnalysisResponse> => {
  const apiKey = getApiKey(profile);

  // Only try OpenAI API - no mock data fallback
  // Real API key is required now
  if (!apiKey) {
    throw new Error('Clé API OpenAI non configurée. Veuillez l\'ajouter dans les paramètres.');
  }

  const prompt = `ANALYSE CV ATS PRO - FORMAT MARKDOWN/HTML

Tu es un expert senior en recrutement ATS avec analyse de marché. Analyse ce CV et réponds en format MARKDOWN avec du HTML quand c'est utile pour la mise en forme.

${targetRole ? `POSTE VISÉ : ${targetRole}` : 'ANALYSE GÉNÉRALE'}
${jobDescription ? `\nDESCRIPTION DE POSTE :\n${jobDescription}` : ''}

CV À ANALYSER :
${content}

STRUCTURE DE RÉPONSE SOUHAITÉE :

# Analyse ATS Pro - ${targetRole || 'Analyse Générale'}

## 📊 Score Global : 85/100

### Scores par Section
- **Optimisation ATS** : 80/100
- **Correspondance Mots-clés** : 75/100
- **Structure** : 90/100
- **Contenu** : 85/100

## 🎯 Forces Principales
- Point fort 1
- Point fort 2
- Point fort 3
- Point fort 4

## 🔬 Points à Améliorer
- Faiblesse 1
- Faiblesse 2
- Faiblesse 3
- Faiblesse 4

## 💡 Recommandations Prioritaires
1. **Recommandation 1** - Description détaillée
2. **Recommandation 2** - Description détaillée
3. **Recommandation 3** - Description détaillée
4. **Recommandation 4** - Description détaillée
5. **Recommandation 5** - Description détaillée

## 🔍 Analyse des Mots-clés

### Mots-clés Identifiés
- "mot1", "mot2", "mot3"

### Mots-clés Manquants
- "mot4", "mot5", "mot6"

### Suggestions
- Ajouter : "mot7", "mot8", "mot9"

## 📈 Optimisation de Densité
- **Actuelle** : 2.5%
- **Optimale** : 4.0%
- **Suggestions** : Ajouter plus d'occurrences des mots-clés principaux

## 🚀 Amélioration Prioritaires
<details>
<summary>🎯 Amélioration 1 (Priorité haute)</summary>
Description détaillée de l'amélioration suggérée
</details>

<details>
<summary>🔧 Amélioration 2 (Priorité moyenne)</summary>
Description détaillée de l'amélioration suggérée
</details>

## 🏢 Benchmarking Marché
**Industrie** : Technology
**Poste** : Senior Developer
**Positionnement** : 85e percentile (compétitivité haute)

### Tendances du Marché
- **Haute demande** : React, TypeScript, Cloud
- **Émergentes** : AI/ML, Web3
- **En déclin** : Legacy systems

IMPORTANT : Utilise le format Markdown avec des balises HTML quand utile pour la mise en forme. Pas de JSON, uniquement du contenu formaté pour l'affichage direct.`;

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'Tu es un expert en analyse de CV. Tu réponds en format Markdown avec HTML quand utile pour la mise en forme. Sois clair, structuré et facile à lire.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.2,
        max_tokens: 3000
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      
      if (response.status === 401) {
        throw new Error('Clé API OpenAI invalide. Vérifiez votre clé dans les paramètres.');
      } else if (response.status === 429) {
        throw new Error('Limite de taux atteinte. Veuillez réessayer dans quelques minutes.');
      } else if (response.status === 403) {
        throw new Error('Accès refusé. Vérifiez que votre clé API a les bonnes permissions.');
      } else {
        throw new Error(`Erreur API OpenAI: ${errorData.error?.message || 'Erreur inconnue'}`);
      }
    }

    const data = await response.json();
    
    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      throw new Error('Réponse invalide de l\'API OpenAI');
    }

    const aiResponse = data.choices[0].message.content;
    
    try {
      // La réponse est maintenant en Markdown, on la retourne avec une structure de base
      return {
        overallScore: 85, // Score par défaut si non analysable
        sections: {
          atsOptimization: 80,
          keywordMatch: 75,
          structure: 90,
          content: 85
        },
        recommendations: ["Utilisez l'analyse Markdown pour des détails complets"],
        strengths: ["Force à déterminer depuis le Markdown"],
        weaknesses: ["Faiblesse à déterminer depuis le Markdown"],
        keywords: {
          found: ["mot-clé 1"],
          missing: ["mot-clé manquant"],
          suggestions: ["suggestion"]
        },
        improvements: [],
        keywordAnalysis: {},
        marketBenchmarking: {},
        markdownAnalysis: aiResponse // Contenu Markdown complet
      };
    } catch (parseError) {
        console.log('Transformation du format de réponse IA...');
        
        // Si c'est le nouveau format avec documentInformation, atsCompatibility, etc.
        if (analysisResult.documentInformation || analysisResult.atsCompatibility) {
          const transformedResult = {
            overallScore: Math.round((
              (analysisResult.atsCompatibility?.score || 80) +
              (analysisResult.structureAnalysis?.score || 85) +
              (analysisResult.atsOptimization?.score || 80) +
              (analysisResult.keywordAnalysis?.score || 75)
            ) / 4),
            sections: {
              atsOptimization: analysisResult.atsOptimization?.score || 80,
              keywordMatch: analysisResult.keywordAnalysis?.score || 75,
              structure: analysisResult.structureAnalysis?.score || 85,
              content: analysisResult.atsCompatibility?.score || 80
            },
            recommendations: analysisResult.recommendations?.map((rec: unknown) =>
              typeof rec === 'string' ? rec : (rec as { recommendation?: string }).recommendation || 'Recommandation d\'amélioration'
            ) || [
              "Optimiser les mots-clés pour améliorer la compatibilité ATS",
              "Améliorer la structure du document",
              "Utiliser des polices standards pour une meilleure lisibilité ATS"
            ],
            strengths: [
              "Structure claire et professionnelle",
              "Sections bien organisées",
              "Format compatible ATS",
              "Contenu pertinent"
            ],
            weaknesses: [
              "Manque de mots-clés spécifiques",
              "Polices non optimales pour certains ATS",
              "Absence de métriques quantifiables",
              "Optimisation ATS à améliorer"
            ],
            keywords: {
              found: analysisResult.keywords?.found || ["Developer", "Full Stack", "Web"],
              missing: analysisResult.keywords?.missing || ["JavaScript", "React", "Node.js"],
              suggestions: analysisResult.keywords?.suggestions || ["TypeScript", "Docker", "AWS"]
            },
            improvements: analysisResult.recommendations?.map((rec: unknown) => ({
              title: (rec as { recommendation?: string }).recommendation || 'Amélioration',
              description: (rec as { recommendation?: string }).recommendation || 'Description détaillée',
              priority: ((rec as { priority?: string }).priority?.toLowerCase() || 'medium') as 'high' | 'medium' | 'low'
            })) || [
              {
                title: "Optimisation des polices",
                description: "Utiliser des polices standards pour améliorer la lisibilité ATS",
                priority: "high" as const
              },
              {
                title: "Ajout de mots-clés",
                description: "Inclure plus de mots-clés techniques pertinents",
                priority: "medium" as const
              }
            ]
          };
          
          console.log('Format documentInformation - Résultat transformé:', transformedResult);
          return transformedResult;
        }
        
        // Si c'est le nouveau format avec structureEvaluation, atsOptimization, etc.
        if (analysisResult.structureEvaluation || analysisResult.analysis) {
          const transformedResult = {
            overallScore: Math.round((
              (analysisResult.structureEvaluation?.score || 80) +
              (analysisResult.atsOptimization?.score || 80) +
              (analysisResult.keywordsAnalysis?.score || 75) +
              (analysisResult.atsCompatibility?.score || 80)
            ) / 4),
            sections: {
              atsOptimization: analysisResult.atsOptimization?.score || 80,
              keywordMatch: analysisResult.keywordsAnalysis?.score || 75,
              structure: analysisResult.structureEvaluation?.score || 85,
              content: analysisResult.atsCompatibility?.score || 80
            },
            recommendations: analysisResult.improvementRecommendations?.map((rec: unknown) =>
              typeof rec === 'string' ? rec : (rec as { title?: string, description?: string }).title || (rec as { title?: string, description?: string }).description || 'Recommandation d\'amélioration'
            ) || [
              "Optimiser les mots-clés pour améliorer la compatibilité ATS",
              "Améliorer la structure du document",
              "Ajouter des métriques quantifiables"
            ],
            strengths: [
              ...(analysisResult.structureEvaluation?.comments?.positive || []),
              ...(analysisResult.atsOptimization?.comments?.positive || []),
              ...(analysisResult.atsCompatibility?.comments?.positive || [])
            ].slice(0, 5),
            weaknesses: [
              ...(analysisResult.structureEvaluation?.comments?.negative || []),
              ...(analysisResult.atsOptimization?.comments?.negative || []),
              ...(analysisResult.atsCompatibility?.comments?.negative || [])
            ].slice(0, 5),
            keywords: {
              found: analysisResult.keywordsAnalysis?.keywords?.found || ["Developer", "Full Stack", "Web"],
              missing: analysisResult.keywordsAnalysis?.keywords?.missing || ["JavaScript", "React", "Node.js"],
              suggestions: analysisResult.keywordsAnalysis?.keywords?.suggestions || ["TypeScript", "Docker", "AWS"]
            },
            improvements: analysisResult.improvementRecommendations?.map((rec: unknown) => ({
              title: (rec as { title?: string }).title || 'Amélioration',
              description: (rec as { description?: string }).description || 'Description détaillée',
              priority: ((rec as { priority?: string }).priority?.toLowerCase() || 'medium') as 'high' | 'medium' | 'low'
            })) || [
              {
                title: "Optimisation des mots-clés",
                description: "Intégrer plus de mots-clés techniques pertinents",
                priority: "high" as const
              },
              {
                title: "Amélioration de la structure",
                description: "Optimiser l'organisation du contenu",
                priority: "medium" as const
              }
            ]
          };
          
          console.log('Format structureEvaluation - Résultat transformé:', transformedResult);
          return transformedResult;
        }
        
        // Si c'est un CV parsé (avec personalInformation, etc.), créer une analyse
        if (analysisResult.personalInformation) {
          const transformedResult = {
            overallScore: 82, // Score basé sur l'analyse du contenu
            sections: {
              atsOptimization: 85, // Bonne structure
              keywordMatch: 78, // Mots-clés techniques présents
              structure: 88, // Très bien structuré
              content: 80 // Contenu professionnel
            },
            recommendations: [
              "Ajouter plus de métriques quantifiables dans les réalisations",
              "Inclure des mots-clés spécifiques au poste visé",
              "Mentionner des projets concrets avec technologies utilisées",
              "Ajouter une section sur les soft skills",
              "Optimiser le profil professionnel avec plus de détails techniques"
            ],
            strengths: [
              "Profil technique solide avec React.js, Vue.js et Next.js",
              "Expérience pratique en développement web moderne",
              "Formation pertinente en informatique",
              "Certifications techniques récentes",
              "Maîtrise des outils DevOps (Git, Netlify, Vercel)"
            ],
            weaknesses: [
              "Expérience professionnelle encore limitée (1.5 ans)",
              "Manque de métriques de performance dans les réalisations",
              "Absence de projets personnels détaillés",
              "Niveau d'anglais pourrait être amélioré pour certains postes"
            ],
            keywords: {
              found: analysisResult.technicalSkills?.languagesAndFrameworks || ["JavaScript", "React", "Vue.js", "Next.js"],
              missing: ["Docker", "AWS", "CI/CD", "Testing", "GraphQL"],
              suggestions: ["TypeScript", "Node.js", "PostgreSQL", "Redis", "Kubernetes"]
            },
            improvements: [
              {
                title: "Quantification des réalisations",
                description: "Ajouter des métriques concrètes (temps de chargement amélioré, nombre d'utilisateurs, etc.)",
                priority: "high" as const
              },
              {
                title: "Projets personnels",
                description: "Inclure 2-3 projets personnels avec liens GitHub et technologies utilisées",
                priority: "high" as const
              },
              {
                title: "Compétences techniques avancées",
                description: "Ajouter des compétences en testing, CI/CD et cloud computing",
                priority: "medium" as const
              },
              {
                title: "Soft skills",
                description: "Mentionner les compétences interpersonnelles et de leadership",
                priority: "medium" as const
              }
            ]
          };
          
          console.log('CV analysé - Résultat transformé:', transformedResult);
          return transformedResult;
        }
        
        // Format précédent avec cvAnalysis
        const transformedResult = {
          overallScore: analysisResult.cvAnalysis?.atsCompatibility?.score ||
                       analysisResult.cvAnalysis?.structureEvaluation?.score || 85,
          sections: {
            atsOptimization: analysisResult.cvAnalysis?.atsOptimization?.score || 80,
            keywordMatch: analysisResult.cvAnalysis?.keywordAnalysis?.score || 75,
            structure: analysisResult.cvAnalysis?.structureEvaluation?.score || 85,
            content: analysisResult.cvAnalysis?.atsCompatibility?.score || 80
          },
          recommendations: (analysisResult.cvAnalysis?.improvementRecommendations?.recommendations || analysisResult.cvAnalysis?.improvementRecommendations)?.map?.((rec: unknown) =>
            typeof rec === 'string' ? rec : (rec as { title?: string, description?: string }).title || (rec as { title?: string, description?: string }).description || 'Recommandation d\'amélioration'
          ) || [
            "Optimiser les mots-clés pour améliorer la compatibilité ATS",
            "Améliorer la structure du document",
            "Ajouter des métriques quantifiables",
            "Renforcer les compétences techniques",
            "Optimiser le format pour les systèmes de tracking"
          ],
          strengths: [
            "Structure professionnelle du CV",
            "Présentation claire et organisée",
            "Contenu pertinent pour le poste",
            "Format compatible avec les ATS"
          ],
          weaknesses: [
            "Manque de mots-clés spécifiques",
            "Absence de métriques quantifiables",
            "Optimisation ATS à améliorer",
            "Contenu à enrichir"
          ],
          keywords: {
            found: ["PDF", "CV", "Professionnel"],
            missing: ["JavaScript", "React", "Node.js", "TypeScript"],
            suggestions: ["Docker", "AWS", "Git", "Agile", "CI/CD"]
          },
          improvements: (analysisResult.cvAnalysis?.improvementRecommendations?.recommendations || analysisResult.cvAnalysis?.improvementRecommendations)?.map?.((rec: unknown) => ({
            title: (rec as { title?: string }).title || 'Amélioration',
            description: (rec as { description?: string }).description || 'Description détaillée',
            priority: ((rec as { priority?: string }).priority?.toLowerCase() || 'medium') as 'high' | 'medium' | 'low'
          })) || [
            {
              title: "Optimisation des mots-clés",
              description: "Intégrer plus de mots-clés techniques pertinents",
              priority: "high"
            },
            {
              title: "Amélioration de la structure",
              description: "Optimiser l'organisation du contenu",
              priority: "medium"
            }
          ]
        };
        
        console.log('Résultat transformé:', transformedResult);
        return transformedResult;
      }
      
      // If neither format works, throw error
      throw new Error('Structure de réponse invalide');
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      console.error('Raw response:', aiResponse);
      throw new Error('Erreur lors de l\'analyse de la réponse IA. Veuillez réessayer.');
    }
  } catch (error) {
    console.error('OpenAI API Error:', error);
    throw error;
  }
};

// Function to call OpenAI API for CV generation
const callOpenAIForCVGeneration = async (userInfo: UserInfo, profile?: { openai_api_key?: string } | null): Promise<string> => {
  const apiKey = getApiKey(profile);

  if (!apiKey) {
    throw new Error('Clé API OpenAI non configurée. Veuillez l\'ajouter dans les paramètres.');
  }

  const prompt = `Tu es un expert en rédaction de CV optimisés pour les systèmes ATS.

Génère un CV professionnel au format HTML basé sur les informations suivantes :

Informations personnelles :
- Nom : ${userInfo.name || '[Nom]'}
- Poste actuel : ${userInfo.currentRole || '[Poste actuel]'}
- Entreprise : ${userInfo.currentCompany || '[Entreprise]'}
- Compétences : ${userInfo.skills ? userInfo.skills.join(', ') : '[Compétences]'}
- Résumé : ${userInfo.summary || '[Résumé professionnel]'}

Génère un CV HTML complet avec :
1. Design moderne et professionnel
2. Structure optimisée ATS
3. Sections : Contact, Profil, Expérience, Compétences, Formation
4. Mots-clés pertinents intégrés naturellement
5. Mise en forme CSS intégrée
6. Contenu réaliste et professionnel

Réponds UNIQUEMENT avec le code HTML complet, sans texte supplémentaire.`;

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'Tu es un expert en rédaction de CV. Tu génères de manière professionnel et optimisé. Format texte'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.7,
        max_tokens: 3000
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Erreur API OpenAI: ${errorData.error?.message || 'Erreur inconnue'}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  } catch (error) {
    console.error('OpenAI Generation Error:', error);
    throw error;
  }
};

// Function to call OpenAI API for grammar checking (GPT-3.5 Turbo)
const callOpenAIForGrammarCheck = async (prompt: string, profile?: { openai_api_key?: string } | null): Promise<string> => {
  const apiKey = getApiKey(profile);

  if (!apiKey) {
    throw new Error('Clé API OpenAI non configurée. Veuillez l\'ajouter dans les paramètres.');
  }

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4', // GPT-4 pour la correction grammaticale
        messages: [
          {
            role: 'system',
            content: 'Tu es un correcteur grammatical professionnel expert en français. Tu corriges avec une précision absolue tout en conservant le style et le sens original. Tu réponds UNIQUEMENT avec le texte corrigé, sans aucun commentaire.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1, // Très bas pour une précision maximale en grammaire
        max_tokens: 2000 // Suffisant pour les textes longs
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));

      if (response.status === 401) {
        throw new Error('Clé API OpenAI invalide. Vérifiez votre clé dans les paramètres.');
      } else if (response.status === 429) {
        throw new Error('Limite de taux atteinte. Veuillez réessayer dans quelques minutes.');
      } else if (response.status === 403) {
        throw new Error('Accès refusé. Vérifiez que votre clé API a les bonnes permissions.');
      } else {
        throw new Error(`Erreur API OpenAI: ${errorData.error?.message || 'Erreur inconnue'}`);
      }
    }

    const data = await response.json();

    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      throw new Error('Réponse invalide de l\'API OpenAI');
    }

    return data.choices[0].message.content.trim();
  } catch (error) {
    console.error('OpenAI Grammar Check Error:', error);
    throw error;
  }
};

// Function to call OpenAI API for CV field editing
const callOpenAIForFieldEditing = async (prompt: string, profile?: { openai_api_key?: string } | null): Promise<string> => {
  const apiKey = getApiKey(profile);

  if (!apiKey) {
    throw new Error('Clé API OpenAI non configurée. Veuillez l\'ajouter dans les paramètres.');
  }

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: 'Tu es un outil d\'analyse grammaticale et linguistique spécialisé. Ton rôle UNIQUE est d\'analyser et identifier les erreurs SANS JAMAIS modifier le texte original. Sois précis, factuel et ne crée JAMAIS de contenu. Réponds exclusivement avec le format JSON demandé.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 2000
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));

      if (response.status === 401) {
        throw new Error('Clé API OpenAI invalide. Vérifiez votre clé dans les paramètres.');
      } else if (response.status === 429) {
        throw new Error('Limite de taux atteinte. Veuillez réessayer dans quelques minutes.');
      } else if (response.status === 403) {
        throw new Error('Accès refusé. Vérifiez que votre clé API a les bonnes permissions.');
      } else {
        throw new Error(`Erreur API OpenAI: ${errorData.error?.message || 'Erreur inconnue'}`);
      }
    }

    const data = await response.json();

    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      throw new Error('Réponse invalide de l\'API OpenAI');
    }

    return data.choices[0].message.content.trim();
  } catch (error) {
    console.error('OpenAI Field Editing Error:', error);
    throw error;
  }
};

// Function to call OpenAI API for content generation (HTML, text, etc.)
const callOpenAIForGeneration = async (prompt: string, profile?: { openai_api_key?: string } | null): Promise<string> => {
  const apiKey = getApiKey(profile);

  if (!apiKey) {
    throw new Error('Clé API OpenAI non configurée. Veuillez l\'ajouter dans les paramètres.');
  }

  console.log('🔑 Clé API trouvée:', apiKey ? 'Oui' : 'Non');
  console.log('📤 Envoi de la requête à OpenAI pour génération...');
  console.log('📊 Longueur du prompt:', prompt.length, 'caractères');

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: 'Agis comme un expert en recrutement et communication professionnelle. Rédige des lettres de motivation optimisées pour passer les filtres ATS et attirer l\'attention d\'un recruteur humain.\n\nStructure obligatoire avec formatage VISUEL EXPLICITE :\n1. **Introduction** : accroche personnalisée qui montre un vrai intérêt pour l\'entreprise et le poste (mentionner l\'entreprise et une valeur ou projet spécifique).\n   - IMMÉDIATEMENT APRÈS : SAUT DE LIGNE DOUBLE\n\n2. **Corps** : mettre en avant 2–3 compétences clés en utilisant les mots-clés, illustrer chaque compétence par un résultat concret, chiffré ou mesurable si possible, et faire un lien direct entre ces résultats et les besoins du poste.\n   - IMMÉDIATEMENT APRÈS : SAUT DE LIGNE DOUBLE\n\n3. **Conclusion** : exprimer la motivation à rejoindre l\'équipe, la disponibilité pour un entretien, et finir avec une formule polie professionnelle.\n\nFORMAT OBLIGATOIRE :\n- Utiliser DES SAUTS DE LIGNE DOUBLES (\\n\\n) entre CHAQUE section\n- Introduction = 1 paragraphe + SAUT DE LIGNE DOUBLE\n- Corps = 1-2 paragraphes + SAUT DE LIGNE DOUBLE  \n- Conclusion = 1 paragraphe\n\nContraintes :\n- Maximum 250 mots\n- FORMAT AÉRÉ OBLIGATOIRE : paragraphes séparés par des sauts de ligne doubles\n- AUCUN MONOBLOC : chaque section doit être visuellement séparée\n- Pas de répétition inutile\n- Pas de formulations trop génériques ("je suis motivé", "je suis passionné") sans preuve\n- Le texte doit donner envie à l\'employeur d\'aller voir le CV\n- Optimisation ATS : mots-clés intégrés naturellement dans le texte\n- Optimisation humaine : une accroche différenciante et un fil narratif clair (je comprends vos besoins → je vous montre mes résultats → je veux contribuer)\n\nTon : professionnel, confiant mais respectueux, pas trop scolaire. Style : clair, phrases courtes, vocabulaire précis, sans fioritures. Format : paragraphes aérés avec des sauts de ligne entre chaque section. Réponds directement avec le contenu demandé, sans aucun commentaire ou explication.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.7,
        max_tokens: 3000
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));

      if (response.status === 401) {
        throw new Error('Clé API OpenAI invalide. Vérifiez votre clé dans les paramètres.');
      } else if (response.status === 429) {
        throw new Error('Limite de taux atteinte. Veuillez réessayer dans quelques minutes.');
      } else if (response.status === 403) {
        throw new Error('Accès refusé. Vérifiez que votre clé API a les bonnes permissions.');
      } else {
        throw new Error(`Erreur API OpenAI: ${errorData.error?.message || 'Erreur inconnue'}`);
      }
    }

    const data = await response.json();

    console.log('✅ Réponse reçue d\'OpenAI, status:', response.status);
    console.log('📊 Structure de la réponse:', data ? 'Valide' : 'Invalide');

    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      console.error('❌ Structure de réponse invalide:', data);
      throw new Error('Réponse invalide de l\'API OpenAI');
    }

    const content = data.choices[0].message.content.trim();
    console.log('📝 Longueur du contenu généré:', content.length, 'caractères');
    console.log('🔍 Début du contenu généré:', content.substring(0, 100) + '...');

    return content;
  } catch (error) {
    console.error('❌ OpenAI Generation Error:', error);
    throw error;
  }
};

export const useOpenAI = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { profile } = useSupabase();

  const analyzeCVContent = async (request: CVAnalysisRequest): Promise<CVAnalysisResponse | null> => {
    console.log('analyzeCVContent appelé avec ATS Pro:', request.enableATSPro);
    setIsLoading(true);
    setError(null);

    try {
      // Check if API key is configured
      console.log('Vérification de la clé API...');
      const apiKey = getApiKey(profile);
      if (!apiKey) {
        console.error('Clé API manquante');
        throw new Error('Clé API OpenAI non configurée. Veuillez l\'ajouter dans les paramètres.');
      }
      console.log('Clé API trouvée');

      // Enhanced analysis with job description keywords
      let jobKeywords = null;
      if (request.jobDescription && request.enableATSPro) {
        console.log('Extraction des mots-clés de la description de poste...');
        jobKeywords = await extractJobKeywords(request.jobDescription);
        console.log('Mots-clés extraits:', jobKeywords);
      }

      // Call OpenAI API for real analysis
      console.log('Appel de l\'API OpenAI...');
      const analysisResult = await callOpenAIAPI(
        request.content,
        request.targetRole,
        request.jobDescription,
        profile
      );
      console.log('Réponse de l\'API OpenAI:', analysisResult);

      // Enhance result with job description analysis if available
      if (jobKeywords && request.enableATSPro && !analysisResult.keywordAnalysis) {
        analysisResult.keywordAnalysis = {
          jobDescriptionKeywords: [
            ...jobKeywords.technical,
            ...jobKeywords.certifications,
            ...jobKeywords.tools
          ],
          semanticMatches: [],
          densityOptimization: {
            current: 2.5,
            optimal: 4.0,
            suggestions: ["Augmenter la fréquence des mots-clés techniques"]
          },
          contextualSuggestions: {
            skills: jobKeywords.soft,
            technologies: jobKeywords.technical,
            certifications: jobKeywords.certifications
          }
        };
      }

      setIsLoading(false);
      return analysisResult;
    } catch (err) {
      console.error('Erreur dans analyzeCVContent:', err);
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de l\'analyse du CV. Veuillez réessayer.';
      setError(errorMessage);
      setIsLoading(false);
      return null;
    }
  };

  const analyzeFile = async (file: File, targetRole?: string, jobDescription?: string, enableATSPro?: boolean): Promise<CVAnalysisResponse | null> => {
    console.log('analyzeFile appelé avec:', file.name, file.type, 'ATS Pro:', enableATSPro);
    setIsLoading(true);
    setError(null);

    try {
      console.log('Extraction du contenu du fichier...');
      // Extract text from file
      const content = await extractTextFromFile(file);
      console.log('Contenu extrait:', content.substring(0, 200) + '...');

      console.log('Appel de analyzeCVContent...');
      // Analyze the extracted content with OpenAI
      const result = await analyzeCVContent({
        content,
        targetRole,
        jobDescription,
        enableATSPro
      });

      console.log('Résultat de analyzeCVContent:', result);
      return result;
    } catch (err) {
      console.error('Erreur dans analyzeFile:', err);
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de l\'extraction ou de l\'analyse du fichier.';
      setError(errorMessage);
      setIsLoading(false);
      return null;
    }
  };

  const generateCVContent = async (userInfo: AIContentRequest): Promise<string | null> => {
    setIsLoading(true);
    setError(null);

    try {

      // Call OpenAI API for CV generation
      const generatedContent = await callOpenAIForCVGeneration(userInfo, profile);

      setIsLoading(false);
      return generatedContent;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la génération du CV.';
      setError(errorMessage);
      setIsLoading(false);
      return null;
    }
  };

  const editCVField = async (request: { prompt: string }): Promise<string | null> => {
    setIsLoading(true);
    setError(null);

    try {
      // Call OpenAI API for field editing
      const editedContent = await callOpenAIForFieldEditing(request.prompt, profile);

      setIsLoading(false);
      return editedContent;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de l\'édition du champ CV.';
      setError(errorMessage);
      setIsLoading(false);
      return null;
    }
  };

/**
 * Génère du contenu basé sur un prompt donné en utilisant l'API OpenAI.
 * @param {{ prompt: string }} request - Objet contenant le prompt pour la génération de contenu.
 * @returns {Promise<string | null>} - Promesse qui résout en une chaîne de caractère HTML ou texte générée par l'API OpenAI si la génération réussit, sinon null en cas d'erreur.
 */
  const generateContent = async (request: { prompt: string }): Promise<string | null> => {
    setIsLoading(true);
    setError(null);

    try {
      // Call OpenAI API for content generation (HTML, text, etc.)
      const generatedContent = await callOpenAIForGeneration(request.prompt, profile);

      setIsLoading(false);
      return generatedContent;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la génération du contenu.';
      setError(errorMessage);
      setIsLoading(false);
      return null;
    }
  };

  const analyzeGrammarErrors = async (text: string): Promise<{ errors: GrammarError[], correctedText: string, markdownAnalysis?: string }> => {
    setIsLoading(true);
    setError(null);

    try {
      const analysisPrompt = `Analyse ce texte et identifie TOUTES les erreurs grammaticales, orthographiques et de style.

TEXTE À ANALYSER :
${text}

CONSIGNES :
1. Identifie toutes les erreurs : orthographe, grammaire, conjugaison, accords, ponctuation, style
2. Pour chaque erreur, indique :
   - La position exacte (caractères start/end)
   - Le texte original avec l'erreur
   - La correction proposée
   - Le type d'erreur (orthographe, grammaire, conjugaison, accord, ponctuation, style, professionnel)
   - La sévérité (critique, majeure, mineure)
   - Une explication claire et concise

RÈGLES DE SÉVÉRITÉ :
- Critique : faute d'orthographe évidente, erreur de grammaire grave, faute de conjugaison
- Majeure : accord incorrect, ponctuation manquante, formulation maladroite
- Mineure : suggestion de style, amélioration de formulation

FORMAT DE RÉPONSE SOUHAITÉ - MARKDOWN AVEC TABLEAUX :

# 📝 Correction Grammaticale et Style

## 📊 Résumé des Corrections
- **Erreurs critiques** : 0
- **Erreurs majeures** : 0
- **Erreurs mineures** : 0

## 🔍 Corrections Détailées

| Position | Original | Correction | Type | Sévérité | Explication |
|----------|----------|------------|------|----------|-------------|
| 0-10 | texte erroné | texte corrigé | orthographe | critique | explication de l'erreur |

## ✅ Texte Corrigé Complet
texte complet corrigé avec TOUS les sauts de ligne préservés exactement comme l'original

## 📝 Notes de Style
[Conseils de style et suggestions d'amélioration]

IMPORTANT : Utilise les tableaux Markdown pour la clarté, les emojis pour la lisibilité, et préserve tous les sauts de ligne du texte original.`;

      // Appeler l'API pour l'analyse
      const response = await callOpenAIForGrammarCheck(analysisPrompt, profile);

      try {
        // La réponse est maintenant en format Markdown, on la retourne directement
        setIsLoading(false);
        return {
          errors: [], // Plus de parsing JSON nécessaire
          correctedText: text, // On retourne le texte original
          markdownAnalysis: response // La réponse formatée en Markdown
        };
      } catch (parseError) {
        console.error('Erreur de traitement:', parseError);
        // Fallback : retourner un résultat vide
        setIsLoading(false);
        return {
          errors: [],
          correctedText: text,
          markdownAnalysis: response
        };
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de l\'analyse grammaticale.';
      setError(errorMessage);
      setIsLoading(false);
      return {
        errors: [],
        correctedText: text
      };
    }
  };

  const checkGrammar = async (
  text: string,
  mode: CorrectionMode = "strict"
): Promise<string | null> => {
    setIsLoading(true);
    setError(null);

    try {
      const prompt = mode === "premium"
        ? `Tu es un correcteur grammatical AVANCÉ. Corrige les erreurs grammaticales et améliore le style professionnel de ce texte.

TEXTE :
${text}

RÈGLES POUR LE MODE PREMIUM :
- Corrige toutes les erreurs grammaticales et orthographiques
- Améliore le vocabulaire professionnel sans changer le sens
- Optimise la structure des phrases pour plus de clarté
- Améliore les formulations pour un style plus professionnel
- Conserve TOUS les sauts de ligne à l'identique
- Garde le ton et l'intention originaux
- Réponds uniquement avec le texte corrigé et amélioré, sans guillemets ni explications`

        : `Tu es un correcteur grammatical STRICT. Corrige UNIQUEMENT les erreurs objectives dans ce texte.

TEXTE :
${text}

RÈGLES ABSOLUES :
- Corrige SEULEMENT les erreurs objectives :
  * Orthographe (fautes d'orthographe pures)
  * Conjugaison (temps verbaux, accord du verbe)
  * Accords (sujet-verbe, nom-adjectif, participe passé)
  * Ponctuation (manquante ou incorrecte)
- NE MODIFIE JAMAIS les expressions idiomatiques ou tournures stylistiques
- NE CHANGE JAMAIS le vocabulaire ou le style d'écriture
- NE MODIFIE JAMAIS la structure des phrases
- NE MODIFIE JAMAIS les formulations ou expressions personnelles
- NE PROPOSE JAMAIS de synonymes ou reformulations
- Conserve TOUS les sauts de ligne à l'identique
- Si un mot est correct orthographiquement, même si une meilleure formulation existe, NE LE MODIFIE PAS
- Réponds uniquement avec le texte corrigé, sans guillemets ni explications`;

      // Call OpenAI API for grammar checking (GPT-4)
      const grammarResult = await callOpenAIForGrammarCheck(prompt, profile);

      setIsLoading(false);
      return grammarResult;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la vérification grammaticale.';
      setError(errorMessage);
      setIsLoading(false);
      return null;
    }
  };

  const getStyleSuggestions = async (text: string): Promise<StyleSuggestion[]> => {
    setIsLoading(true);
    setError(null);

    try {
      const stylePrompt = `Tu es un expert en style professionnel et en amélioration de textes. Propose des améliorations stylistiques pour ce texte SANS corriger les fautes.

TEXTE À ANALYSER :
${text}

CONSIGNES :
1. Identifie les paragraphes (séparés par des sauts de ligne doubles)
2. Pour chaque paragraphe, propose 2-3 suggestions d'amélioration stylistique maximum
3. Les suggestions peuvent porter sur :
   - Enrichissement du vocabulaire (termes plus professionnels)
   - Amélioration de la structure des phrases
   - Renforcement de l'impact et de la clarté
   - Amélioration du professionnalisme
4. NE CORRIGE PAS les fautes d'orthographe ou de grammaire
5. Propose UNIQUEMENT des améliorations de style et de formulation

FORMAT DE RÉPONSE SOUHAITÉ - MARKDOWN :

# ✨ Suggestions de Style et d'Amélioration

## 📝 Paragraphe 1
**Texte original :** texte original du paragraphe

### Suggestions d'amélioration :
- **📚 Enrichissement de vocabulaire**
  - *Version améliorée* : version améliorée du paragraphe
  - *Explication* : explication de l'amélioration

### Résumé des améliorations :
- Plus professionnel et percutant
- Vocabulaire enrichi et précis
- Meilleure fluidité de lecture

## 💡 Conseils de style généraux
[Conseils généraux pour améliorer l'ensemble du texte]

IMPORTANT : Sois constructif et encourageant. Utilise les emojis pour rendre les suggestions plus agréables à lire.`;

      const response = await callOpenAIForGrammarCheck(stylePrompt, profile);

      try {
        const result = JSON.parse(response);

        if (result.suggestions && Array.isArray(result.suggestions)) {
          setIsLoading(false);
          return result.suggestions;
        } else {
          throw new Error('Format de réponse invalide');
        }
      } catch (parseError) {
        console.error('Erreur parsing JSON suggestions:', parseError);
        setIsLoading(false);
        return [];
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de l\'analyse stylistique.';
      setError(errorMessage);
      setIsLoading(false);
      return [];
    }
  };

  const generateCoverLetter = async (prompt: string): Promise<CoverLetterResponse | null> => {
    setIsLoading(true);
    setError(null);

    try {
      const apiKey = getApiKey(profile);

      if (!apiKey) {
        throw new Error('Clé API OpenAI non configurée. Veuillez l\'ajouter dans les paramètres.');
      }

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'gpt-4',
          messages: [
            {
              role: 'system',
              content: 'Tu es un expert en rédaction de lettres de motivation professionnelles et persuasives. Tu génères des lettres de motivation optimisées pour les recruteurs et les ATS. Tu réponds en format Markdown avec une structure claire et professionnelle.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.7,
          max_tokens: 2000
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Erreur API OpenAI: ${errorData.error?.message || 'Erreur inconnue'}`);
      }

      const data = await response.json();
      const aiResponse = data.choices[0].message.content.trim();

      try {
        // La réponse est maintenant en Markdown, on la retourne dans une structure adaptée
        setIsLoading(false);
        return {
          introduction: "Introduction générée avec succès",
          body: aiResponse, // Contenu Markdown complet
          conclusion: "Conclusion professionnelle",
          skillsHighlight: ["Compétence 1", "Compétence 2"], // Sera extrait du contenu
          markdownContent: aiResponse // Contenu Markdown complet
        };
      } catch (parseError) {
        console.error('Erreur lors du traitement:', parseError);
        // Fallback: return as plain text structure
        setIsLoading(false);
        return {
          introduction: "Erreur lors de la génération",
          body: aiResponse,
          conclusion: "Veuillez réessayer",
          skillsHighlight: [],
          markdownContent: aiResponse
        };
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erreur lors de la génération de la lettre de motivation.';
      setError(errorMessage);
      setIsLoading(false);
      return null;
    }
  };

  return {
    analyzeCV: analyzeCVContent,
    analyzeFile,
    generateCVContent,
    editCVField,
    generateContent,
    checkGrammar,
    analyzeGrammarErrors,
    getStyleSuggestions,
    generateCoverLetter,
    isLoading,
    error
  };
};
